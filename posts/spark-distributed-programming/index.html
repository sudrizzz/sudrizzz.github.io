<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.79.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Anthony"><meta property="og:url" content="https://sudrizzz.github.io/posts/spark-distributed-programming/"><link rel=canonical href=https://sudrizzz.github.io/posts/spark-distributed-programming/><link rel=alternate type=application/atom+xml href=https://sudrizzz.github.ioindex.xml title="Anthony's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/sudrizzz.github.io"},"articleSection":"posts","name":"Spark 分布式内存计算框架","headline":"Spark 分布式内存计算框架","description":"Spark 简介 Spark 是一种基于内存的、用以实现高效集群计算的平台。准确地讲，Spark 是一个大数据并行计算框架，是对广泛使用的 MapReduce 计算模型的扩展。Spark 有着自己的生态系统，但同时兼容 HDFS、Hive 等分布式存储系统，可以完美融入 Hadoop 的生态圈中，代替 MapReduce 去执行更为高效的分布式计算。两者的区别在于：基于 MapReduce 的计算引擎通常会将中间结果输出到磁盘上进行存储和容错；而 Spark 则是将中间结果尽量保存在内存中以减少底层存储系统的 I\/O，以提高计算速度。\nSpark 编程模型 核心数据结构 RDD Spark 将数据抽象成弹性分布式数据集（Resilient Distributed Dataset, RDD），RDD 实际是分布在集群多个节点上数据的集合，通过操作 RDD 对象来并行化操作集群上的分布式数据。\nRDD 有两种创建方式:\n 并行化驱动程序中已有的原生集合; 引用 HDFS、HBase 等外部存储系统上的数据集。  RDD 可以缓存在内存中，每次对 RDD 操作的结果都可以放到内存中，下一次操作时可直接从内存中读取，相对于 MapReduce,它省去了大量的磁盘 I\/O 操作。另外，持久化的 RDD 能够在错误中自动恢复，如果某部分 RDD 丢失，Spark 会自动重算丢失的部分。\nRDD 上的操作 从相关数据源获取初始数据形成初始 RDD 后，需要根据应用的需求对得到的初始 RDD 进行必要的处理，来获取满足需求的数据内容，从而对中间数据进行计算加工，得到最终的数据。\nRDD 支持两种操作，一种是转换（Transformation）操作，另一种是行动（Action）操作。\n转换（Transformation）操作 转换操作即将一个 RDD 转换为一个新的 RDD。值得注意的是，转换操作是惰性的，这就意味着对 RDD 调用某种转换操作时，操作并不会立即执行，而是 Spark 在内部记录下所要求执行的操作的相关信息，当在行动操作中需要用到这些转换出来的 RDD 时才会被计算，下表所示为基本的转换操作。通过转换操作，可以从已有的 RDD 生成出新的 RDD, Spark 使用谱系（Lineage）记录新旧 RDD 之间的依赖关系，一旦持久化的 RDD 丢失部分数据时，Spark 能通过谱系图重新计算丢失的数据。","inLanguage":"en-US","author":"Anthony","creator":"Anthony","publisher":"Anthony","accountablePerson":"Anthony","copyrightHolder":"Anthony","copyrightYear":"2020","datePublished":"2020-10-23 20:00:00 \u002b0800 \u002b0800","dateModified":"2020-10-23 20:00:00 \u002b0800 \u002b0800","url":"https:\/\/sudrizzz.github.io\/posts\/spark-distributed-programming\/","keywords":[]}</script><title>Spark 分布式内存计算框架 - Anthony's Blog</title><meta property="og:title" content="Spark 分布式内存计算框架 - Anthony's Blog"><meta property="og:type" content="article"><meta property="og:description" content="Spark 简介 Spark 是一种基于内存的、用以实现高效集群计算的平台。准确地讲，Spark 是一个大数据并行计算框架，是对广泛使用的 MapReduce 计算模型的扩展。Spark 有着自己的生态系统，但同时兼容 HDFS、Hive 等分布式存储系统，可以完美融入 Hadoop 的生态圈中，代替 MapReduce 去执行更为高效的分布式计算。两者的区别在于：基于 MapReduce 的计算引擎通常会将中间结果输出到磁盘上进行存储和容错；而 Spark 则是将中间结果尽量保存在内存中以减少底层存储系统的 I/O，以提高计算速度。
Spark 编程模型 核心数据结构 RDD Spark 将数据抽象成弹性分布式数据集（Resilient Distributed Dataset, RDD），RDD 实际是分布在集群多个节点上数据的集合，通过操作 RDD 对象来并行化操作集群上的分布式数据。
RDD 有两种创建方式:
 并行化驱动程序中已有的原生集合; 引用 HDFS、HBase 等外部存储系统上的数据集。  RDD 可以缓存在内存中，每次对 RDD 操作的结果都可以放到内存中，下一次操作时可直接从内存中读取，相对于 MapReduce,它省去了大量的磁盘 I/O 操作。另外，持久化的 RDD 能够在错误中自动恢复，如果某部分 RDD 丢失，Spark 会自动重算丢失的部分。
RDD 上的操作 从相关数据源获取初始数据形成初始 RDD 后，需要根据应用的需求对得到的初始 RDD 进行必要的处理，来获取满足需求的数据内容，从而对中间数据进行计算加工，得到最终的数据。
RDD 支持两种操作，一种是转换（Transformation）操作，另一种是行动（Action）操作。
转换（Transformation）操作 转换操作即将一个 RDD 转换为一个新的 RDD。值得注意的是，转换操作是惰性的，这就意味着对 RDD 调用某种转换操作时，操作并不会立即执行，而是 Spark 在内部记录下所要求执行的操作的相关信息，当在行动操作中需要用到这些转换出来的 RDD 时才会被计算，下表所示为基本的转换操作。通过转换操作，可以从已有的 RDD 生成出新的 RDD, Spark 使用谱系（Lineage）记录新旧 RDD 之间的依赖关系，一旦持久化的 RDD 丢失部分数据时，Spark 能通过谱系图重新计算丢失的数据。"><meta name=description content="Spark 简介 Spark 是一种基于内存的、用以实现高效集群计算的平台。准确地讲，Spark 是一个大数据并行计算框架，是对广泛使用的 MapReduce 计算模型的扩展。Spark 有着自己的生态系统，但同时兼容 HDFS、Hive 等分布式存储系统，可以完美融入 Hadoop 的生态圈中，代替 MapReduce 去执行更为高效的分布式计算。两者的区别在于：基于 MapReduce 的计算引擎通常会将中间结果输出到磁盘上进行存储和容错；而 Spark 则是将中间结果尽量保存在内存中以减少底层存储系统的 I/O，以提高计算速度。
Spark 编程模型 核心数据结构 RDD Spark 将数据抽象成弹性分布式数据集（Resilient Distributed Dataset, RDD），RDD 实际是分布在集群多个节点上数据的集合，通过操作 RDD 对象来并行化操作集群上的分布式数据。
RDD 有两种创建方式:
 并行化驱动程序中已有的原生集合; 引用 HDFS、HBase 等外部存储系统上的数据集。  RDD 可以缓存在内存中，每次对 RDD 操作的结果都可以放到内存中，下一次操作时可直接从内存中读取，相对于 MapReduce,它省去了大量的磁盘 I/O 操作。另外，持久化的 RDD 能够在错误中自动恢复，如果某部分 RDD 丢失，Spark 会自动重算丢失的部分。
RDD 上的操作 从相关数据源获取初始数据形成初始 RDD 后，需要根据应用的需求对得到的初始 RDD 进行必要的处理，来获取满足需求的数据内容，从而对中间数据进行计算加工，得到最终的数据。
RDD 支持两种操作，一种是转换（Transformation）操作，另一种是行动（Action）操作。
转换（Transformation）操作 转换操作即将一个 RDD 转换为一个新的 RDD。值得注意的是，转换操作是惰性的，这就意味着对 RDD 调用某种转换操作时，操作并不会立即执行，而是 Spark 在内部记录下所要求执行的操作的相关信息，当在行动操作中需要用到这些转换出来的 RDD 时才会被计算，下表所示为基本的转换操作。通过转换操作，可以从已有的 RDD 生成出新的 RDD, Spark 使用谱系（Lineage）记录新旧 RDD 之间的依赖关系，一旦持久化的 RDD 丢失部分数据时，Spark 能通过谱系图重新计算丢失的数据。"><meta property="og:locale" content="zh-cn"><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/highlight/tomorrow.min.css><link rel=stylesheet href=/css/index.css><link href=/index.xml rel=alternate type=application/rss+xml title="Anthony's Blog"><link href="https://fonts.loli.net/css?family=Arvo|Permanent+Marker|Bree+Serif" rel=stylesheet></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class="signatures site-title"><a href=/>Anthony</a></div></header><div class="row end-xs"></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>Spark 分布式内存计算框架</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2020-10-23 20:00:00 +0800">2020.10.23</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://github.com/sudrizzz/>@Anthony</a></div></div></div></header><div class="post-content markdown-body"><h1 id=spark-简介>Spark 简介</h1><p>Spark 是一种基于内存的、用以实现高效集群计算的平台。准确地讲，Spark 是一个大数据并行计算框架，是对广泛使用的 MapReduce 计算模型的扩展。Spark 有着自己的生态系统，但同时兼容
HDFS、Hive 等分布式存储系统，可以完美融入 Hadoop 的生态圈中，代替 MapReduce 去执行更为高效的分布式计算。两者的区别在于：基于 MapReduce 的计算引擎通常会将中间结果输出到磁盘上进行存储和容错；而 Spark 则是将中间结果尽量保存在内存中以减少底层存储系统的 I/O，以提高计算速度。</p><h1 id=spark-编程模型>Spark 编程模型</h1><h2 id=核心数据结构-rdd>核心数据结构 RDD</h2><p>Spark 将数据抽象成弹性分布式数据集（Resilient Distributed Dataset, RDD），RDD 实际是分布在集群多个节点上数据的集合，通过操作 RDD 对象来并行化操作集群上的分布式数据。</p><p>RDD 有两种创建方式:</p><ol><li>并行化驱动程序中已有的原生集合;</li><li>引用 HDFS、HBase 等外部存储系统上的数据集。</li></ol><p>RDD 可以缓存在内存中，每次对 RDD 操作的结果都可以放到内存中，下一次操作时可直接从内存中读取，相对于 MapReduce,它省去了大量的磁盘 I/O 操作。另外，持久化的 RDD 能够在错误中自动恢复，如果某部分 RDD 丢失，Spark 会自动重算丢失的部分。</p><h2 id=rdd-上的操作>RDD 上的操作</h2><p>从相关数据源获取初始数据形成初始 RDD 后，需要根据应用的需求对得到的初始 RDD 进行必要的处理，来获取满足需求的数据内容，从而对中间数据进行计算加工，得到最终的数据。</p><p>RDD 支持两种操作，一种是转换（Transformation）操作，另一种是行动（Action）操作。</p><h3 id=转换transformation操作>转换（Transformation）操作</h3><p>转换操作即将一个 RDD 转换为一个新的 RDD。值得注意的是，转换操作是惰性的，这就意味着对 RDD 调用某种转换操作时，操作并不会立即执行，而是 Spark 在内部记录下所要求执行的操作的相关信息，当在行动操作中需要用到这些转换出来的 RDD 时才会被计算，下表所示为基本的转换操作。通过转换操作，可以从已有的 RDD 生成出新的 RDD, Spark 使用谱系（Lineage）记录新旧 RDD 之间的依赖关系，一旦持久化的 RDD 丢失部分数据时，Spark 能通过谱系图重新计算丢失的数据。</p><blockquote><p>输入数据为 {1, 2, 3, 3}</p></blockquote><style>table th:first-of-type{width:10%}table th:nth-of-type(2){width:40%}table th:nth-of-type(3){width:20%}table th:nth-of-type(4){width:30%}</style><table><thead><tr><th>函数名</th><th>目的</th><th>示例</th><th style=text-align:center>结果</th></tr></thead><tbody><tr><td>map()</td><td>将数据集中的每个元素经过用户自定义的函数转换形成一个新的 RDD</td><td>rdd.map(x => x * 2)</td><td style=text-align:center>{2, 4, 6, 6}</td></tr><tr><td>flatMap()</td><td>与 map() 类似，但每个元素输入项都可以被映射到 0 个或多个的输出项，最终将结果“扁平化“后输出</td><td>rdd.flatMap(x => (1 to x))</td><td style=text-align:center>{1, 1, 2, 1, 2, 3, 1, 2, 3, 3}</td></tr><tr><td>filter()</td><td>对 RDD 元素进行过滤，把经过指定函数后返回值为 true 的元素组成一个新的 RDD</td><td>rdd.filter(x => (x != 3))</td><td style=text-align:center>{1, 2}</td></tr><tr><td>distinct()</td><td>对数据进行去重，返回一个新的 RDD</td><td>rdd.distinct()</td><td style=text-align:center>{1, 2, 3}</td></tr><tr><td>sample(withReplacement, fraction, seed)</td><td>以指定的随机种子随机抽样出数量为 fraction 的数据，withReplacement 表示是抽出的数据是否放回，true 为有放回的抽样，false 为无放回的抽样</td><td>rdd.sample(true,0.5,3)</td><td style=text-align:center>非确定的</td></tr></tbody></table><h3 id=行动action操作>行动（Action）操作</h3><p>行动操作会触发 Spark 提交作业，对 RDD 进行实际的计算，并将最终求得的结果返回到驱动器程序，或者写入外部存储系统中。由于行动操作会得到一个结果，所以 Spark 会强制对 RDD 的转换操作进行求值，下表所示为基本的行动操作。</p><blockquote><p>输入数据为 {1, 2, 3, 3}</p></blockquote><style>table th:first-of-type{width:20%}table th:nth-of-type(2){width:35%}table th:nth-of-type(3){width:25%}table th:nth-of-type(4){width:20%}</style><table><thead><tr><th>函数名</th><th>目的</th><th>示例</th><th style=text-align:center>结果</th></tr></thead><tbody><tr><td>collect()</td><td>返回 RDD 中的所有元素</td><td>rdd.collect()</td><td style=text-align:center>{1, 2, 3, 3}</td></tr><tr><td>count()</td><td>返回 RDD 中元素的个数</td><td>rdd.count()</td><td style=text-align:center>4</td></tr><tr><td>countByValue()</td><td>返回 RDD 中各元素出现的次数</td><td>rdd.countByValue()</td><td style=text-align:center>{(1, 1), (2, 1), (3, 2)}</td></tr><tr><td>take(n)</td><td>从 RDD 中返回 n 个元素（任意位置）</td><td>rdd.take(2)</td><td style=text-align:center>{2, 3}</td></tr><tr><td>top(n)</td><td>从 RDD 中返回<strong>前</strong> n 个元素</td><td>rdd.top(2)</td><td style=text-align:center>{1, 2}</td></tr><tr><td>reduce(func)</td><td>并行整合 RDD 中的所有数据</td><td>rdd.reduce((x, y) => x + y)</td><td style=text-align:center>9</td></tr><tr><td>fold(zero)(func)</td><td>与 reduce() 类似，但需要提供初始值。加法的默认是 0；乘法的默认是 1</td><td>rdd.fold(1)((x, y) => x + y)</td><td style=text-align:center>10</td></tr><tr><td>aggregate()</td><td>与 reduce() 类似，但通常返回不同类型的函数</td><td>rdd.aggregate((0, 0))<br>((x, y) =><br>(x._1 + y, x._2 + 1),<br>(x, y) =><br>(x._1 + y._1, x._2 + y._2))</td><td style=text-align:center>(9, 4)</td></tr><tr><td>foreach(func)</td><td>对 RDD 中的每个元素使用给定的函数</td><td>rdd.foreach(func)</td><td style=text-align:center>无</td></tr></tbody></table><h1 id=示例>示例</h1><p>以下两个示例的数据集与源代码均可以在下述链接中进行下载
<a href=https://github.com/sudrizzz/BigDataTechnologyFoundation_SourceCodeAndDataSet/tree/main/ch08>https://github.com/sudrizzz/BigDataTechnologyFoundation_SourceCodeAndDataSet/tree/main/ch08</a></p><h2 id=一分词>一、分词</h2><p>WordCount（单词统计程序）是大数据领域经典的例子，与 Hadoop 实现的 WordCount 程序相比，Spark 实现的版本要显得更加简洁。</p><h3 id=从-mapreduce-到-spark>从 MapReduce 到 Spark</h3><p>在经典的计算框架 MapReduce 中，问题会被拆成两个主要阶段: map 阶段和 reduce 阶段。对单词计数来说，MapReduce 程序从 HDFS 中读取一行字符串。在 map 阶段，将字符串分割成单词，并生成 &lt;word, 1> 这样的键值对；在 reduce 阶段，将单词对应的计数值（初始为 1）全部累加起来，最后得到单词的总出现次数。</p><p>在 Spark 中，并没有 map/reduce 这样的划分，而是以 RDD 的转换来呈现程序的逻辑。首先，Spark 程序将从 HDFS 中按行读取的文本作为初始 RDD（即集合的每一个元素都是一行字符串）；然后，通过 flatMap 操作将每一行字符串分割成单词，并收集起来作为新的单词 RDD；接着，使用 map 操作将每一个单词映射成 &lt;word, 1>这样的键值对，转换成新的键值对 RDD；最后，通过 reduceByKey 操作将相同单词的计数值累加起来，得到单词的总出现次数。</p><h3 id=java-实现>Java 实现</h3><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln> 1</span><span class=kn>import</span> <span class=nn>org.apache.spark.SparkConf</span><span class=o>;</span>
<span class=ln> 2</span><span class=kn>import</span> <span class=nn>org.apache.spark.api.java.JavaPairRDD</span><span class=o>;</span>
<span class=ln> 3</span><span class=kn>import</span> <span class=nn>org.apache.spark.api.java.JavaRDD</span><span class=o>;</span>
<span class=ln> 4</span><span class=kn>import</span> <span class=nn>org.apache.spark.api.java.JavaSparkContext</span><span class=o>;</span>
<span class=ln> 5</span><span class=kn>import</span> <span class=nn>scala.Tuple2</span><span class=o>;</span>
<span class=ln> 6</span>
<span class=ln> 7</span><span class=kn>import</span> <span class=nn>java.util.Arrays</span><span class=o>;</span>
<span class=ln> 8</span><span class=kn>import</span> <span class=nn>java.util.List</span><span class=o>;</span>
<span class=ln> 9</span><span class=kn>import</span> <span class=nn>java.util.regex.Pattern</span><span class=o>;</span>
<span class=ln>10</span>
<span class=ln>11</span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SparkDemo</span> <span class=o>{</span>
<span class=ln>12</span>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Pattern</span> <span class=n>kSpace</span> <span class=o>=</span> <span class=n>Pattern</span><span class=o>.</span><span class=na>compile</span><span class=o>(</span><span class=s>&#34; &#34;</span><span class=o>);</span>
<span class=ln>13</span>
<span class=ln>14</span>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
<span class=ln>15</span>        <span class=n>SparkConf</span> <span class=n>conf</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SparkConf</span><span class=o>().</span><span class=na>setAppName</span><span class=o>(</span><span class=s>&#34;WordCount&#34;</span><span class=o>);</span>
<span class=ln>16</span>        <span class=n>JavaSparkContext</span> <span class=n>sc</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JavaSparkContext</span><span class=o>(</span><span class=n>conf</span><span class=o>);</span>
<span class=ln>17</span>
<span class=ln>18</span>        <span class=n>JavaRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>lines</span> <span class=o>=</span> <span class=n>sc</span><span class=o>.</span><span class=na>textFile</span><span class=o>(</span><span class=n>args</span><span class=o>[</span><span class=n>0</span><span class=o>]).</span><span class=na>rdd</span><span class=o>().</span><span class=na>toJavaRDD</span><span class=o>();</span>
<span class=ln>19</span>        <span class=n>JavaRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>words</span> <span class=o>=</span> <span class=n>lines</span><span class=o>.</span><span class=na>flatMap</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>kSpace</span><span class=o>.</span><span class=na>split</span><span class=o>(</span><span class=n>s</span><span class=o>)).</span><span class=na>iterator</span><span class=o>());</span>
<span class=ln>20</span>        <span class=n>JavaPairRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>ones</span> <span class=o>=</span> <span class=n>words</span><span class=o>.</span><span class=na>mapToPair</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=k>new</span> <span class=n>Tuple2</span><span class=o>&lt;&gt;(</span><span class=n>s</span><span class=o>,</span> <span class=n>1</span><span class=o>));</span>
<span class=ln>21</span>        <span class=n>JavaPairRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>counts</span> <span class=o>=</span> <span class=n>ones</span><span class=o>.</span><span class=na>reduceByKey</span><span class=o>(</span><span class=n>Integer</span><span class=o>::</span><span class=n>sum</span><span class=o>);</span>
<span class=ln>22</span>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Tuple2</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>output</span> <span class=o>=</span> <span class=n>counts</span><span class=o>.</span><span class=na>collect</span><span class=o>();</span>
<span class=ln>23</span>
<span class=ln>24</span>        <span class=k>for</span> <span class=o>(</span><span class=n>Tuple2</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>tuple</span> <span class=o>:</span> <span class=n>output</span><span class=o>)</span> <span class=o>{</span>
<span class=ln>25</span>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>tuple</span><span class=o>.</span><span class=na>_1</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; : &#34;</span> <span class=o>+</span> <span class=n>tuple</span><span class=o>.</span><span class=na>_2</span><span class=o>());</span>
<span class=ln>26</span>        <span class=o>}</span>
<span class=ln>27</span>        <span class=n>sc</span><span class=o>.</span><span class=na>close</span><span class=o>();</span>
<span class=ln>28</span>    <span class=o>}</span>
<span class=ln>29</span><span class=o>}</span>
</code></pre></div><h3 id=运行过程分析>运行过程分析</h3><ol><li>初始化
创建配置文件 SparkConf，这里仅设置应用名称；再创建 JavaSparkContext，在程序中主要通过 JavaSparkContext 来访问 Spark 集群；</li><li>处理数据<ol><li>根据参数使用 Spark.read().textFile() 方法按行读取输入文件，并转换成 RDD lines；</li><li>使用 flatMap 操作将所有行按空格分割切割成词，并生成新的 RDD words；</li><li>使用 map 操作( Java 中为 mapToPair )，将词映射成 &lt;word, 1>键值对 RDD ones，其中 1 表示出现一次；</li><li>使用 reduceByKey 操作将所有相同的 word 对应的计数累加起来，得到新的 RDD counts；</li><li>使用 collect 操作将所有结果打印出来；</li></ol></li><li>关闭 JavaSparkContext。</li></ol><h3 id=执行>执行</h3><p>将上述代码生成 Jar 包之后，将其放到服务器中，执行下面的命令即可开始运行。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=ln>1</span>./bin/spark-submit --class SparkDemo ~/Documents/SparkDemo.jar ~/Documents/sample.txt
</code></pre></div><p>其中</p><ul><li>&ndash;class SparkDemo 用来指定主类名</li><li>~/Documents/SparkDemo.jar 指定 Jar 包路径</li><li>~/Documents/sample.txt 指定测试文本路径</li></ul><p>sample.txt 文本内容如下所示</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback><span class=ln> 1</span>Your want text it even a text notes having wrong even about fake want or not even but. Language way contentwise just language contentwise recipes set start are. Recipes a words than with meeting days ?looks? even than is name story more story words generator anything gone. Having story but fairly random some adequate want it set has a kind looking having. Fantasy anything you looks just copy work text random sets even fake having. Piece some recipes repetitive adequate wrong wrong way options to repetitive working some dummy repetitive copy realistic you fake. Work or just fairly with is unrelated having language about set forever not game repetitive adequate now you looks it of even dummy now. That but design language unrelated copy you text placeholder has review those of with fake. Random to want the has gardening which business some realistic that and just work. Gardening you realistic kind and name looks about name words words way which some name.
<span class=ln> 2</span>
<span class=ln> 3</span>The that copy story realistic the adequate text meeting options game gone piece has options has name random. Days wrong set realistic design repetitive adequate review text your or but having start about right are story fairly fairly but to language sets adequate. But work want sets right kind some having contentwise fairly convincing language notes right name from but want realistic unrelated words. From about generator not looks or fairly copy has more. Forever from gone which or that having a with some having the work wrong generator design a fantasy way convincing. Working in dummy not now happily but to it of happily story want those kind looking right words business it generator language are. A you anything sets fake sets kind notes meeting having has in copy realistic is you. Copy or fairly set story.
<span class=ln> 4</span>
<span class=ln> 5</span>Wrong and days not work of want piece options unrelated way random just just recipes. Your recipes gardening start fairly. Happily start game days want from in set meeting that forever random. Support has wrong than your language are random business a even design has. Way design dummy unrelated set generator game convincing. Text contentwise copy to of set kind notes a you ?looks? gone work. Way forever result you to not. Your your meeting generator way placeholder looking than has want in repetitive more kind start has you but language a. A than notes name story and a just days some with in options looking just not are want looks. Kind some from review even.
<span class=ln> 6</span>
<span class=ln> 7</span>Some start random meeting recipes is a a ?looks? unrelated more the about but are dummy. Words review fake now kind of you meeting it design your. To just a about to. Not realistic name from with fake is. Work even business options fake wrong result notes want the more has dummy a notes random. Gone right repetitive fairly want now it want days review. Has notes want random name that random fantasy not unrelated in is dummy work work random game design now. Business result a and piece from working. Your some recipes copy sets are has kind story support fantasy has and some fantasy a which anything are the.
<span class=ln> 8</span>
<span class=ln> 9</span>Language piece that kind copy right anything dummy a of copy which fantasy placeholder which the work are convincing random. Your gone way copy you copy are that game but looking gardening result is start text the words the a anything. Want piece set set fantasy generator sets a more are happily or ?looks? just the and sets not anything. Support to just start game work looks copy that in of but words placeholder support now fairly fake even now. Text adequate words not fairly looks from game that result name realistic or you fake working want. Kind you some looking of review has sets than want the way working has. Of fantasy gardening and kind just game those adequate your from or text are you story working happily. Business set way gardening more dummy want are you business ?looks? work to placeholder are design options sets having. Working from options work right not meeting story it is of which way fake meeting. Adequate story than words want the anything.
<span class=ln>10</span>
<span class=ln>11</span>Language some gone random or just fairly gone which adequate sets having and adequate or text random from review. From unrelated those a start the ?looks? game business. With copy and which set kind game contentwise which anything the set story notes about or forever. Way anything work ?looks? a contentwise adequate and meeting. Options which realistic words it of to right game random way random your those and those anything some you notes gone gardening dummy than fake. But language just a your work with that set the. Are dummy business story not gardening start wrong fantasy fake and words having text which recipes your ?looks? wrong or. Generator fake than set looking text now forever more design ?looks? text but than has than wrong.
<span class=ln>12</span>
<span class=ln>13</span>Way than fake gardening those a now it language but piece. A is even looks just result that which realistic gone are working right fake some. Which language wrong having with that looks.
</code></pre></div><p>执行结果如下所示</p><pre><code>right : 9
Fantasy : 1
review : 5
convincing : 2
is : 8
Business : 2
even : 1
Are : 1
even : 10
start : 10
// 此处省略数行
</code></pre><h2 id=二统计用户的视频上传数>二、统计用户的视频上传数</h2><h3 id=场景分析>场景分析</h3><p>接下来使用 Spark 来统计 Youtube 的测试数据集中每个用户的视频上传数量。稍加分析，会发现统计每个用户的视频数量其实与 WordCount 中统计每个单词出现的次数的逻辑几乎一致，区别在于处理 Youtube 测试数据集的格式略为复杂些。将给定的数据集按行划分，每行代表一条记录，除了视频类别这一字段中间有可能出现空格之外，其他的字段都是用空格分割。可以考虑使用正则表达式来匹配记录，并提取所需要的信息。</p><p>在测试数据集中，假定每行所代表的视频都是唯一的，所以仅仅需要用户 ID 这一条信息。在提取到用户 ID 之后，可以像 WordCount 一样，组成 &lt;ID, 1> 这样的用来计数的键值对，这步之后的逻辑便与 WordCount 相似了。</p><h3 id=java-实现-1>Java 实现</h3><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=ln> 1</span><span class=kn>import</span> <span class=nn>org.apache.spark.SparkConf</span><span class=o>;</span>
<span class=ln> 2</span><span class=kn>import</span> <span class=nn>org.apache.spark.api.java.JavaPairRDD</span><span class=o>;</span>
<span class=ln> 3</span><span class=kn>import</span> <span class=nn>org.apache.spark.api.java.JavaRDD</span><span class=o>;</span>
<span class=ln> 4</span><span class=kn>import</span> <span class=nn>org.apache.spark.api.java.JavaSparkContext</span><span class=o>;</span>
<span class=ln> 5</span><span class=kn>import</span> <span class=nn>scala.Tuple2</span><span class=o>;</span>
<span class=ln> 6</span>
<span class=ln> 7</span><span class=kn>import</span> <span class=nn>java.util.ArrayList</span><span class=o>;</span>
<span class=ln> 8</span><span class=kn>import</span> <span class=nn>java.util.List</span><span class=o>;</span>
<span class=ln> 9</span><span class=kn>import</span> <span class=nn>java.util.regex.Matcher</span><span class=o>;</span>
<span class=ln>10</span><span class=kn>import</span> <span class=nn>java.util.regex.Pattern</span><span class=o>;</span>
<span class=ln>11</span>
<span class=ln>12</span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SparkDemo</span> <span class=o>{</span>
<span class=ln>13</span>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Pattern</span> <span class=n>EXTRACT</span> <span class=o>=</span> <span class=n>Pattern</span><span class=o>.</span><span class=na>compile</span><span class=o>(</span><span class=s>&#34;(\\S+)\\s+(\\S+)\\s+(\\d+)\\s+(\\D+[a-zA-Z])\\s+(\\d+)\\s+(\\d+)\\s+(\\d+\\.?\\d*)\\s+(\\d+)\\s+(\\d+)\\s+(.*)&#34;</span><span class=o>);</span>
<span class=ln>14</span>
<span class=ln>15</span>    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
<span class=ln>16</span>        <span class=n>SparkConf</span> <span class=n>conf</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SparkConf</span><span class=o>().</span><span class=na>setAppName</span><span class=o>(</span><span class=s>&#34;CountUploader&#34;</span><span class=o>);</span>
<span class=ln>17</span>        <span class=n>JavaSparkContext</span> <span class=n>sc</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JavaSparkContext</span><span class=o>(</span><span class=n>conf</span><span class=o>);</span>
<span class=ln>18</span>
<span class=ln>19</span>        <span class=n>JavaRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>lines</span> <span class=o>=</span> <span class=n>sc</span><span class=o>.</span><span class=na>textFile</span><span class=o>(</span><span class=n>args</span><span class=o>[</span><span class=n>0</span><span class=o>]);</span>
<span class=ln>20</span>        <span class=n>JavaRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>filtered</span> <span class=o>=</span> <span class=n>lines</span><span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=n>EXTRACT</span><span class=o>.</span><span class=na>matcher</span><span class=o>(</span><span class=n>s</span><span class=o>).</span><span class=na>matches</span><span class=o>());</span>
<span class=ln>21</span>        <span class=n>JavaPairRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>records</span> <span class=o>=</span> <span class=n>filtered</span><span class=o>.</span><span class=na>mapToPair</span><span class=o>(</span><span class=n>s</span> <span class=o>-&gt;</span> <span class=o>{</span>
<span class=ln>22</span>            <span class=n>Matcher</span> <span class=n>m</span> <span class=o>=</span> <span class=n>EXTRACT</span><span class=o>.</span><span class=na>matcher</span><span class=o>(</span><span class=n>s</span><span class=o>);</span>
<span class=ln>23</span>            <span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>m</span><span class=o>.</span><span class=na>matches</span><span class=o>();</span>
<span class=ln>24</span>            <span class=k>return</span> <span class=k>new</span> <span class=n>Tuple2</span><span class=o>&lt;&gt;(</span><span class=n>m</span><span class=o>.</span><span class=na>group</span><span class=o>(</span><span class=n>2</span><span class=o>),</span> <span class=n>m</span><span class=o>.</span><span class=na>group</span><span class=o>(</span><span class=n>1</span><span class=o>));</span>
<span class=ln>25</span>        <span class=o>});</span>
<span class=ln>26</span>        <span class=n>JavaPairRDD</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>groups</span> <span class=o>=</span> <span class=n>records</span><span class=o>.</span><span class=na>groupByKey</span><span class=o>().</span><span class=na>mapToPair</span><span class=o>(</span><span class=n>t</span> <span class=o>-&gt;</span> <span class=o>{</span>
<span class=ln>27</span>            <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
<span class=ln>28</span>            <span class=n>t</span><span class=o>.</span><span class=na>_2</span><span class=o>().</span><span class=na>forEach</span><span class=o>(</span><span class=n>list</span><span class=o>::</span><span class=n>add</span><span class=o>);</span>
<span class=ln>29</span>            <span class=k>return</span> <span class=k>new</span> <span class=n>Tuple2</span><span class=o>&lt;&gt;(</span><span class=n>t</span><span class=o>.</span><span class=na>_1</span><span class=o>(),</span> <span class=n>list</span><span class=o>);</span>
<span class=ln>30</span>        <span class=o>});</span>
<span class=ln>31</span>        <span class=c1>// 手动实现 sortBy 操作
</span><span class=ln>32</span><span class=c1></span>        <span class=n>JavaRDD</span><span class=o>&lt;</span><span class=n>Tuple2</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;&gt;</span> <span class=n>tops</span> <span class=o>=</span> <span class=n>groups</span><span class=o>.</span><span class=na>keyBy</span><span class=o>(</span><span class=n>t</span> <span class=o>-&gt;</span> <span class=n>t</span><span class=o>.</span><span class=na>_2</span><span class=o>().</span><span class=na>size</span><span class=o>()).</span><span class=na>sortByKey</span><span class=o>(</span><span class=kc>false</span><span class=o>).</span><span class=na>values</span><span class=o>();</span>
<span class=ln>33</span>        <span class=n>List</span><span class=o>&lt;</span><span class=n>Tuple2</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;&gt;</span> <span class=n>topList</span> <span class=o>=</span> <span class=n>tops</span><span class=o>.</span><span class=na>take</span><span class=o>(</span><span class=n>100</span><span class=o>);</span>
<span class=ln>34</span>
<span class=ln>35</span>        <span class=k>for</span> <span class=o>(</span><span class=n>Tuple2</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;&gt;</span> <span class=n>t</span> <span class=o>:</span> <span class=n>topList</span><span class=o>)</span> <span class=o>{</span>
<span class=ln>36</span>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;User: &#34;</span> <span class=o>+</span> <span class=n>t</span><span class=o>.</span><span class=na>_1</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34;, Number of videos: &#34;</span> <span class=o>+</span> <span class=n>t</span><span class=o>.</span><span class=na>_2</span><span class=o>().</span><span class=na>size</span><span class=o>());</span>
<span class=ln>37</span>        <span class=o>}</span>
<span class=ln>38</span>        <span class=n>sc</span><span class=o>.</span><span class=na>stop</span><span class=o>();</span>
<span class=ln>39</span>    <span class=o>}</span>
<span class=ln>40</span><span class=o>}</span>
</code></pre></div><h3 id=执行-1>执行</h3><p>将上述代码生成 Jar 包之后，将其放到服务器中，执行下面的命令即可开始运行。</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash><span class=ln>1</span>./bin/spark-submit --class SparkDemo ~/Documents/SparkDemo.jar ~/Documents/YoutubeDataSets.txt
</code></pre></div><p>执行结果如下所示</p><pre><code>User: machinima, Number of videos: 21
User: hotforwords, Number of videos: 19
User: theevang1, Number of videos: 19
User: kushtv, Number of videos: 19
User: supermac18, Number of videos: 18
User: NBA, Number of videos: 18
User: somedia, Number of videos: 17
User: tokiohotelchannel, Number of videos: 17
User: AtheneWins, Number of videos: 16
User: davidisbetterthenyou, Number of videos: 16
// 此处省略数行
</code></pre><h1 id=参考文章>参考文章</h1><ol><li><a href=http://spark.apache.org/docs/latest/rdd-programming-guide.html#transformations>RDD Operations</a></li><li><a href=https://www.cnblogs.com/MOBIN/p/5373256.html>Spark 函数详解系列之 RDD 基本转换</a></li><li><a href=https://juejin.im/post/6844904147502759943>Spark 教程之 RDD 操作-转换和执行（示例）</a></li><li><a href=https://yxnchen.github.io/technique/Spark%E7%AC%94%E8%AE%B0-%E7%8E%A9%E8%BD%ACRDD%E6%93%8D%E4%BD%9C/>Spark 笔记-玩转 RDD 操作</a></li><li><a href=https://stackoverflow.com/questions/37018249/rdd-aggregate-in-spark>RDD Aggregate in spark</a></li><li><a href=http://dblab.xmu.edu.cn/blog/1327/>利用开发工具 IntelliJ IDEA 编写 Spark 应用程序（Scala+Maven）</a></li></ol></div><div class="row middle-xs"><div class=col-xs-12><div class=post-category><a href=/categories/hadoop>hadoop</a></div></div></div><div class=row><div class=col-xs-12></div></div><div style=height:50px></div><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"],],},};</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><div class=site-footer><div class=site-footer-item><a href=https://github.com/sudrizzz/ target=_blank>Github</a></div><div class=site-footer-item><a href=mailto:sudrizzz@google.com target=_blank>Email</a></div><div class=site-footer-item><a href="https://music.163.com/song?id=356827" target=_blank>~</a></div></div></div></div></article><script src=/js/highlight.pack.js></script><script src=/js/lazyload.min.js></script><script>var lazyImage=new LazyLoad({container:document.getElementById('article')});</script><script>hljs.initHighlightingOnLoad();</script></body></html>